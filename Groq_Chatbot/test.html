<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Autogrow Test</title>
    <style>
      body {
        background: #0f172a;
        color: #fff;
        padding: 24px;
        font-family: system-ui;
      }
      .bar {
        max-width: 800px;
        margin: 0 auto;
        display: flex;
        gap: 8px;
        align-items: flex-start;
      }
      textarea {
        flex: 1;
        min-height: 40px;
        box-sizing: border-box;
        padding: 8px;
        font-size: 16px;
        border-radius: 6px;
        border: 1px solid #334155;
        background: #0b1220;
        color: #fff;
        resize: none;
      }
    </style>
  </head>
  <body>
    <h3>Autogrow test</h3>
    <div class="bar">
      <textarea id="user-input" placeholder="Type or paste..."></textarea>
      <button>Send</button>
    </div>

    <!-- Paste the exact mirror sizer script here -->
    <script>
      (function attachAutoGrow() {
        const ta = document.getElementById("user-input");
        if (!ta) {
          console.error("AutoGrow: #user-input not found");
          return;
        }

        // === Config ===
        const MAX_PX = 192; // match Tailwind max-h-[12rem] if desired

        // === Create hidden mirror sizer (resilient to transforms & flex) ===
        const sizer = document.createElement("div");
        sizer.setAttribute("aria-hidden", "true");
        Object.assign(sizer.style, {
          position: "absolute",
          visibility: "hidden",
          height: "auto",
          top: "0",
          left: "-9999px",
          whiteSpace: "pre-wrap",
          wordWrap: "break-word",
          overflowWrap: "break-word",
          boxSizing: "border-box",
        });
        document.body.appendChild(sizer);

        // Helper: copy critical styles so measurement matches visual layout
        function copyStyles() {
          const cs = getComputedStyle(ta);
          const props = [
            "width",
            "paddingTop",
            "paddingRight",
            "paddingBottom",
            "paddingLeft",
            "borderTopWidth",
            "borderRightWidth",
            "borderBottomWidth",
            "borderLeftWidth",
            "fontFamily",
            "fontSize",
            "fontWeight",
            "fontStyle",
            "letterSpacing",
            "textTransform",
            "lineHeight",
            "textIndent",
            "tabSize",
            "wordSpacing",
            "whiteSpace",
          ];
          props.forEach((p) => (sizer.style[p] = cs[p]));
          // ensure sizer uses same width as textarea (account for box-sizing)
          sizer.style.width = ta.getBoundingClientRect().width + "px";
        }

        // Resize function uses mirror to compute exact height (robust)
        function resize() {
          copyStyles();
          // mirror content; add trailing newline ensures last line height counted
          const value = ta.value || ta.placeholder || "";
          sizer.textContent = value + "\n";
          const needed = sizer.scrollHeight;

          // apply height constrained by MAX_PX
          ta.style.height = "auto"; // reset so scrollHeight is accurate
          const newHeight = Math.min(needed, MAX_PX);
          ta.style.height = newHeight + "px";
          ta.style.overflowY = needed > MAX_PX ? "auto" : "hidden";
        }

        // Attach events: input, paste (deferred), change, programmatic checks
        ta.addEventListener("input", (e) => {
          // console debug to verify attachment
          if (window.__AUTOGROW_DEBUG) console.log("autogrow: input");
          resize();
        });

        ta.addEventListener("change", () => resize());

        ta.addEventListener("paste", () => {
          // pasted content is applied after paste event, so defer resize
          setTimeout(resize, 0);
        });

        // If content may be inserted programmatically, observe attribute/value changes
        const observer = new MutationObserver((mutations) => {
          for (const m of mutations) {
            if (m.type === "attributes" && m.attributeName === "value") {
              resize();
              break;
            }
          }
        });
        observer.observe(ta, { attributes: true });

        // Recompute on window resize (text wrapping changes height)
        window.addEventListener("resize", resize);

        // Initial sizing for prefilled values
        setTimeout(resize, 0);

        // Expose a manual hook if you want to trigger programmatically
        ta.autogrowResize = resize;

        // Debug hint
        if (window.__AUTOGROW_DEBUG)
          console.log("autogrow attached to #user-input");
      })();
    </script>
  </body>
</html>
